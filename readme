第一章 引言
1.组件的用户永远不应该被其行为所迷惑。
2.小到一个单独的方法，大到包含多个软件包的框架，都可以被称为一个组件
3.代码应该背重用，而不是被拷贝。

第二章  创建和销毁对象
1.用静态工程方法代替构造器：
	优势：
	（1）静态工程工厂与构造器不同的第一大优势在于，他们有名称。 同名但不同参的构造器不是一个好方法， 使用者因为只能看到同一个名字的构造器，无法准确理解和使用。但使用静态方法可以很好的解决这个问题，因为静态工厂方法有名称！
	（2）不必再每次调用的时候创建一个新对象，这样可以使得原对象可以确保为单例的、不可实例化的。这样也可以减少创建对象的内存消耗，以提升性能。
	（3）可以返回原返回类型的任何子类型的对象。（减少对外暴露的信息，提高内聚，使用者可以使用一个超类）
	（4）所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。
	（5）方法返回的对象所属的类，在编写包含该静态工程方法的类时可以不存在。（引出一个概念--服务提供者框架。）
		服务提供者框架包含三个重要的组件：
		1.服务接口--提供者实现的
		2.服务访问API--提供者用来注册实现的
		3.提供者注册API--客户端用来获取服务的实例
		4.服务提供者接口（可选的）
	劣势：
	（1）类如果不含共有的或者受保护的构造器，就不能被子类化。 这一点实际上也有好处，鼓励程序员使用复合（Composition）而不是集成。
	（2）程序员很难发现，也不知道怎么用。 有一些规范化的命名规范：from、vauleOf、getInstance、newInstance等等
	
	总结：静态工厂方法和公有构造器都各有用处，我们需要理解他们各自的长处。 静态工厂经常更加适合，因此切忌第一反应就是提供共有的构造器，而不优先考虑静态工厂。

2.遇到多个构造器参数时要考虑使用构建器（代码待补充）
	首先说一下，一个对象在参数非常多的时候我们可选的三种初始化方式：重叠构造器模式、JavaBean模式、构建器
	1.重叠构造器模式（多个构造器，包含不同的参数个数）
		不好用，客户端使用起来非常痛苦，容易出错且代码难以阅读。
	2.JavaBean模式（Setter函数）
		代码容易阅读，但是线程不安全，也容易出现不可预期的错误。
	3.建造者模式
		代码冗长，但是阅读性和扩展性都非常好，也不会影响到原来的逻辑。
	
	总结：如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是一种不错的选择，特别是当大多数参数都是可选或者类型相同的时候。
	
3.用私有构造器或者枚举类型强化Singleton属性
	Singleton的三种方法
	（1）公有静态成员是个final域，公有域
	 public static final Kewen INSTANCE = new Kewen();
	这样做的好处在于：清晰的表达了它是一个Singleton，而且它更简单。
	（2）公有成员是个静态工厂方法，静态工厂
	Private static final Kewen INSTANCE = new Kewen();
	Public static final getInstance() {return INSTANCE;}
	这样做的好处在于：提供了可变的机制和扩展的机制，可以改为非单例的，或者每个线程返回一个实例的。
	（3）包含单个元素的枚举类型
	Public enum Kewen{
		INSTANCE;
		xxxxxx
	}
	
4.通过私有构造器强化不可实例化的能力
	比如说一些工具类，实例化是毫无意义的，那么为了杜绝它可能存在的被实例化的方式。
	Public class KewenUtils{
		Private KewenUtils(){};
	}
	
5.优先考虑依赖注入来引用资源
	这个非常好理解，想一下Spring就明白了，实际上就是标注的依赖注入
	这种设计很好的提升了代码的可测试性和拓展性
	
6.避免创建不必要的对象
	（1）注意可以能反复创建的同样对象，可以采用静态对象处理，跟随类一起初始化一次即可
	（2）优先使用几杯类型而不是封装类型：例如优先使用long而不是Long
	
7.消除过期的对象引用
	这里实际上主要说的是内存泄漏问题
	（1）类时自己管理内存的，就需要警惕内存泄露问题
	（2）内存泄露的第二个常见来源是缓存
	（3）内存泄露的第三个常见来源是监听器和其他回调
	推荐使用weakHashMap处理缓存和回调

8.避免使用终结方法和清除方法
	（1）终结方法是不可预测的，一般来说是危险的
	（2）使用终结方法和清除方法有一个非常严重的性能损失。 （用try-wicth-resource 可以提升大约50倍的速度）
	（3）终结方法有一个严重的安全问题---终结方法攻击（finializer attack）
	总结：除非是作为安全网或者终止非关键的本地资源，否则不要使用清理方法，对于java9以前的发行版本，则尽量不要使用终结方法
	
9.try-with-resource优先于try-finally
	（1）对比一下，写法也简洁了很多
	
	总结：在处理必须关闭的资源时，始终优先考虑使用try-with-resources


第三章：
	10. 覆盖equals时请遵守通用约定（AutoValue框架可以更好的实现这一点）
	（1）不被覆盖的equals对比的对象是否相等，而不是逻辑相等（一般指值是否相等）
	（2）注意几个约定：自反、传递、逆反、对称、一致
	（3）equals方法写完之后，记得单元测试：对称、传递和一致
	告诫：
	（1）覆盖equals方法时总要覆盖hashCode
	（2）不要企图让equals变得非常智能，一般来说简单比较一下值即可
	（3）不要讲equals生命中的Object对象替换为其他的类型
	（4）让IDE生成equals方法和hashCode方法， 因为程序不会粗心，但程序员会
	
	11. 覆盖equals时总要覆盖hashCode   （这个没怎么看，同上，自动生成一下，不要自己写）
	
	12. 始终要覆盖toString
	（1）Obecjt自带的toString方法返回的一般不是我们期望看见的东西
	（2）提供好的toString方法可以使类用起来更加舒适，使系统便于调试
	（3）toString方法中应该返回对象的所包含的全部值得关注的信息
	
	13. 谨慎的覆盖Clone  （这个也没怎么看，一般场景下不要覆盖Clone）
	
	
	14. 考虑实现Comparable接口
	这个只建议为排序敏感的类实现，其他对象类建议不要实现Comparable接口，避免客户端难以理解其行为
	
第四章
15.使类的成员的可访问性最小化

